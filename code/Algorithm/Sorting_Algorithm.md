# 🔑선택 정렬 (Selection Sort)



## 🎇선택 정렬 개념
**현재 위치에 들어갈 값을 찾아 정렬하는 방법**  

현재 위치에 저장 될 값의 크기에 따라 두 개로 구분됨  

**최소 선택 정렬(Min Selection Sort)**, **최대 선택 정렬(Max Selection Sort)**  

**최소 선택 정렬은 오름차순**으로, **최대 선택 정렬은 내림 차순**으로 정렬  

## 🪧기본 로직

1. 정렬 되지 않은 인덱스의 맨 앞에서 부터, 이를 포함한 그 이후의 배열값 중 **가장 작은 값**을 찾아감  
(정렬되지 않은 인덱스의 맨 앞은 초기 입력에선 배열의 시작위치)  

2. 가장 작은 값을 찾으면, 그 값을 **현재 인덱스의 값과 바꿔줌**  

3. 다음 인덱스에서 위의 과정을 반복  

전체 비교를 진행하므로 **시간복잡도**는 **O(n^2)**, 단 하나의 배열에서만 진행하므로 **공간복잡도**는 **O(n)**  

![](./img/selection.gif)  


# 🔑삽입 정렬(Insertion Sort)



## 🎇삽입 정렬 개념
**현재 위치에서, 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아 그 위치에 삽입하여 정렬하는 방법**  

## 🪧기본 로직

1. 삽입정렬은 두 번째 인덱스부터 시작함,  
현재 인덱스는 별도의 변수에 저장해주고, 비교 인덱스를 현재 인덱스 -1로 잡는다  

2. 별도로 저장해 둔 삽입을 위한 변수와 비교인덱스의 배열값을 비교  

3. 삽입 변수의 값이 더 작으면 현재 인덱스로 비교 인덱스의 값을 저장해주고, 비교 인덱스를 -1하여 비교를 반복  

4. 만약 삽입 변수가 더 크면 비교 인덱스+1에 삽입 변수를 저장  

최악의 경우엔 **시간복잡도**는 **O(n^2)**, 이미 정렬되어 있는 경우에는 **O(n)**  

하지만 상한을 기준으로 하는 **Big O notation**은 최악의 경우를 기분으로 평가하므로, **시간 복잡도**는 **O(n^2)**  

공간 복잡도는 단 하나의 배열에서만 진행하므로 **O(n)**  

![](./img/insertion.gif)  


# 🔑버블 정렬(Bubble Sort)



## 🎇버블 정렬 개념
**매번 연속된 두 개의 인덱스를 비교하여, 정한 기준의 값을 뒤로 넘겨 정렬하는 방법**  
오름차순으로 정렬하고자 할 경우 비교시 마다 큰 값이 뒤로 이동하여 한바퀴 돌 땐 가장 큰 값이 맨 뒤에 저장됨  
맨 마지막에는 비교하는 수들 중 가장 큰 값이 저장되기 때문에 (전체 배열의 크기 - 현재까지 순환한 바퀴 수)만큼만 반복하면 됨  

## 🪧기본 로직

1. 첫 번째와 두 번째 인덱스부터 시작, 현재 인덱스 값과, 바로 이전의 인덱스 값을 비교

2. 이전 인덱스가 더 크면 현재 인덱스와 바꿈  

3. 현재 인덱스가 더 크면 교환하지 않고 다음 두 연속된 배열 값을 비교함  

4. 이를 **(전체 배열의 크기 - 현재까지 순환한 바퀴 수)**만큼 반복  

1부터 비교를 시작하여 n-1개, n-2개, ... 1개씩 비교를 반복함  

선택 정렬과 같이 배열이 어떻게 되어있던지 간에 전체 비교를 진행하므로 **시간 복잡도**는 **O(n^2)**  

공간 복잡도는 단 하나의 배열에서만 진행하므로 **O(n)**  

![](./img/bubble.gif)  

