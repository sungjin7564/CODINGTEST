# 🔑선택 정렬 (Selection Sort)



## 🎇선택 정렬 개념
현재 위치에 들어갈 값을 찾아 정렬하는 방법  

현재 위치에 저장 될 값의 크기에 따라 두 개로 구분됨  

**최소 선택 정렬(Min Selection Sort)**, **최대 선택 정렬(Max Selection Sort)**  

**최소 선택 정렬은 오름차순**으로, **최대 선택 정렬은 내림 차순**으로 정렬  

## 🪧기본 로직

1. 정렬 되지 않은 인덱스의 맨 앞에서 부터, 이를 포함한 그 이후의 배열값 중 **가장 작은 값**을 찾아감  
(정렬되지 않은 인덱스의 맨 앞은 초기 입력에선 배열의 시작위치)  

2. 가장 작은 값을 찾으면, 그 값을 **현재 인덱스의 값과 바꿔줌**  

3. 다음 인덱스에서 위의 과정을 반복  

전체 비교를 진행하므로 **시간복잡도**는 **O(n^2)**, 단 하나의 배열에서만 진행하므로 **공간복잡도**는 **O(n)**  

![](./img/selection.gif)  


# 🔑삽입 정렬(Insertion Sort)



## 🎇삽입 정렬 개녕
현재 위치에서, 그 이하의 배열들을 비교하여 자신이 들어갈 위치를 찾아 그 위치에 삽입하여 정렬하는 방법  

## 🪧기본 로직

1. 삽입정렬은 두 번째 인덱스부터 시작함,  
현재 인덱스는 별도의 변수에 저장해주고, 비교 인덱스를 현재 인덱스 -1로 잡는다  

2. 별도로 저장해 둔 삽입을 위한 변수와 비교인덱스의 배열값을 비교  

3. 삽입 변수의 값이 더 작으면 현재 인덱스로 비교 인덱스의 값을 저장해주고, 비교 인덱스를 -1하여 비교를 반복  

4. 만약 삽입 변수가 더 크면 비교 인덱스+1에 삽입 변수를 저장  
  
  
최악의 경우엔 **시간복잡도**는 **O(n^2)**, 이미 정렬되어 있는 경우에는 **O(n)**  

하지만 상한을 기준으로 하는 **Big O notation**은 최악의 경우를 기분으로 평가하므로, **시간 복잡도**는 **O(n^2)**  

공간 복잡도는 단 하나의 배열에서만 진행하므로 **O(n)**  

![](./img/insertion.gif)  


